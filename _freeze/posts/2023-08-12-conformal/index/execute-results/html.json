{
  "hash": "9e2fa55050bd55fc0ade9390dc704765",
  "result": {
    "markdown": "---\ntitle: \"Conformalized Local Linear Forests\"\ndescription: |\n  Generating conformal uncertainty bands for local linear regression forests \nauthor:\n  - name: Jack T. Rametta \n    url: https://jackrametta.com\n    orcid: 0000-0002-9841-146X\ndate: 2023-08-12\ncitation: \n  url: https://cetialphafive.github.io/jrametta/posts/2023-08-12-conformal/\ncategories: [conformal, ML]\nbibliography: references.bib\ndraft: false\n---\n\n\nThis post briefly demonstrates how to generate conformal uncertainty bands/intervals in `R` employing the [`cfcausal`](https://lihualei71.github.io/cfcausal/index.html) package wrapped around the [local linear forest estimator](https://grf-labs.github.io/grf/articles/llf.html) from the [`grf`](https://grf-labs.github.io/grf/index.html) package. I don't spend much time here explaining how conformal intervals are constructed, for that see [@lei2018distribution] and [@samii2019].\n\nFor the purpose of this demo, we'll use a modified version of the data generating process (DGP) from [@friedman1991multivariate], namely:\n\n$$y=10 \\sin (\\pi x 1 x 2)+20(x 3-0.5)^2+10 x 4+5 x 5+e$$where $e \\sim N(0,1)$. In addition to the five covariates that are related to the outcome, there are also 25 noise covariates unrelated to the outcome (all $\\sin N(0,1)$). This particular DGP as proved challenging for the Gaussian confidence intervals constructed using the standard local linear forest method (see the Monte Carlo simulations presented in [@friedberg2020local], equation 7).\n\nDGP simulated below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Packages (apologies, this is a dependency heavy script!)  \npacman::p_load(\"mlbench\",\"grf\",\"cfcausal\",\"caret\",\n               \"reshape2\",\"glmnet\",\"tidyverse\", \"ggthemes\",\n               \"ggdist\",\"ggpubr\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set seed for reproducibility \nset.seed(1995)\n# Simulate the DGP\np <- 20 #20 additional predictor vars \nn <- 500 #sample size  \njunk <- matrix(rnorm(n * p), n, p) #junk predictors \ndata <- mlbench::mlbench.friedman1(n) #friedman MARs DGP...\ndata <- data.frame(y = data$y, x = data$x,junk) #...adding more junk\n#\n# Split train/test set\ntrainIndex <- caret::createDataPartition(data$y, p=0.7, list = FALSE) #70/30 split \ntrain <- data[trainIndex,]\ntest <- data[-trainIndex,]\n#\n# Convenience objects \nY <- train$y\nY.test <- test$y\nX <- train[,-1]\nX.test <- test[,-1]\n# \n```\n:::\n\n\nNow we can move on to training the local linear forest, we'll enable the local linear split feature and use cross-validated lasso to select the correction features.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# local linear regression forest with LL splits enabled \nc.forest.ll <- grf::ll_regression_forest(X = as.matrix(X), Y = Y, \n                                    #tune.parameters = \"all\", #can't have this with ll splits, IRL you'd want to do a custom tuning loop \n                                    enable.ll.split = TRUE, ll.split.weight.penalty = TRUE,\n                                    num.trees = 4000, #upping from default for stable variance estimates \n                                    seed = 1995) \n# \n# Select covariates for local linear correction \nlasso.mod  <- glmnet::cv.glmnet(as.matrix(X), Y, alpha = 1,  nfolds = 20) #cross-validated lasso \nlasso.coef <- predict(lasso.mod, type = \"nonzero\")\nselected   <- lasso.coef[,1] \n#\n# out-of-sample preds, could also look at oob preds (leave out the testing set and use X instead)\npreds.ll <- predict(c.forest.ll,X.test,estimate.variance = TRUE,linear.correction.variables = selected)\n# data frame for plots later, adding built-in grf uncertainty intervals \nplot.df <- data.frame(ll.preds   = preds.ll$predictions,\n                      ll.upper   = preds.ll$predictions + 1.96*sqrt(preds.ll$variance.estimates), #grf 95% confidence intervals\n                      ll.lower   = preds.ll$predictions - 1.96*sqrt(preds.ll$variance.estimates),\n                      Y = Y.test)\n# column to indicate whether the uncertainty band contains the true value (for plotting)\nplot.df$ll.cover   <- as.factor(ifelse(Y.test >= plot.df$ll.lower & Y.test <= plot.df$ll.upper,1,0))\n```\n:::\n\n\nIn order to generate the conformal intervals, we first need to setup a function that will estimate the local linear forest model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Setup the llf function to plugin to cfcausal, same settings and seed as above\nllRF <- function(Y, X, Xtest, ...){\n  fit <- grf::ll_regression_forest(X, Y,  enable.ll.split = TRUE,\n                                   ll.split.weight.penalty = TRUE,num.trees = 4000,seed = 1995,...)\n  \n  # Same selection procedure \n  lasso.mod <- glmnet::cv.glmnet(as.matrix(X), Y, alpha = 1,  nfolds = 20) \n  lasso.coef <- predict(lasso.mod, type = \"nonzero\")\n  selected <- lasso.coef[,1] \n  #\n  # out-of sample preds\n  res <- predict(c.forest.ll,Xtest,estimate.variance = FALSE,linear.correction.variables = selected) #turn off grf variance estimates \n  # \n  res <- as.numeric(res$predictions)\n  return(res)\n}\n```\n:::\n\n\nWe can then feed that function into the `cfcausal::conformal` function to generate unweighted standard conformal intervals.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Setup the conformal prediction function plugging in our llf estimator \nc.test <- cfcausal::conformal(X = X,Y = Y, type = \"mean\", side = \"two\", \n                              wtfun = NULL, #unweighted \n                              outfun = llRF, #our custom output function\n                              useCV = FALSE) # Note: we're using split conformal here, you could alternatively use CV+ by setting useCV = FALSE. \nll.preds.conformal <- predict(c.test,X.test,alpha = .025) #generate the uncertainty bands, here we're .025\n# Save out the results \nplot.df$ll.upper.c <- ll.preds.conformal$upper\nplot.df$ll.lower.c <- ll.preds.conformal$lower\n# Column for whether truth is covered or not in a given instance, for plotting \nplot.df$ll.cover.c <- as.factor(ifelse(Y.test >= plot.df$ll.lower.c & Y.test <= plot.df$ll.upper.c,1,0))\n```\n:::\n\n\nNow we can plot a comparison between the local linear forest model predictions wrapped in the standard Gaussian and conformal intervals (both aiming for 95% coverage). The y-axis here is model predictions and associated uncertainty bands, the X axis are the true values for y in the testing set.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# llf plot with grf uncertainty bands \nll.plot <- plot.df %>% \n           ggplot(aes(y = ll.preds, x = Y.test, ymin = ll.lower, ymax = ll.upper,color = ll.cover)) + \n           geom_pointinterval(alpha = .5,shape = 1) + \n           scale_x_continuous(limits = c(0,30), expand = c(0, 0)) +\n           scale_y_continuous(limits = c(0,30), expand = c(0, 0)) +\n           geom_abline(linewidth = .75, intercept = 0,slope = 1) + \n           ylab(\"LLF Predictions (Y), 95% Confidence Intervals\") + \n           xlab(\"Y (Real, Test Set)\") + \n           ggtitle(\"Local Linear Forests\") +\n           ggthemes::theme_few()+ \n           scale_color_manual(values = c(\"firebrick1\",\"dodgerblue\")) + \n           guides(color=guide_legend(title=\"Cover Truth? (Blue = Yes)\")) + \n           annotate(\"text\", x = 20, y = 5, label = \"Coverage = .28\",\n           parse = TRUE)\n# llf plot with conformal bands \nll.plot.c <- plot.df %>% \n             ggplot(aes(y = ll.preds, x = Y.test, ymin = ll.lower.c, ymax = ll.upper.c,color = ll.cover.c)) + \n             geom_pointinterval(alpha = .5,shape = 1) + \n             scale_x_continuous(limits = c(0,30), expand = c(0, 0)) +\n             scale_y_continuous(limits = c(0,30), expand = c(0, 0)) +\n             geom_abline(linewidth = .75, intercept = 0,slope = 1) + \n             ylab(\"LLF Predictions (Y), 95% Conformal Intervals\") + \n             xlab(\"Y (Real, Test Set)\") + \n             ggtitle(\"LL Forests w/ Conformal Bands\") +\n             ggthemes::theme_few()+ \n             guides(color=guide_legend(title=\"Cover Truth? (Blue = Yes)\")) + \n             scale_color_manual(values = c(\"firebrick1\",\"dodgerblue\")) + \n           annotate(\"text\", x = 20, y = 5, label = \"Coverage == .95\",\n           parse = TRUE)\n# \nggpubr::ggarrange(ll.plot,ll.plot.c,nrow = 1,common.legend = TRUE,legend = \"bottom\") \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/comparison plots-1.png){width=2100}\n:::\n:::\n\n\nAs the figure makes clear, the conformal bands achieve a much better coverage rate relative to the Gaussian confidence bands. Indeed, in this particular example the conformal approach reaches exactly the desired 95% coverage, while the Gaussian confidence bands achieve only 28%.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}